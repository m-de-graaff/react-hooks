name: Release

on:
  push:
    tags:
      - "v*.*.*"

# Ensure the workflow has permissions to create releases and upload assets
permissions:
  contents: write # required to create releases / upload release assets
  packages: write

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    env:
      TAG_NAME: ${{ github.ref_name }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"
          cache: "pnpm"
          registry-url: "https://registry.npmjs.org"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build
        run: pnpm run build

      # Extract version from tag
      - name: Extract version from tag
        id: get_version
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      # Generate changelog
      - name: Generate changelog
        id: changelog
        run: |
          # Get the previous tag
          PREV_TAG=$(git describe --abbrev=0 --tags $(git rev-list --tags --skip=1 --max-count=1) 2>/dev/null || echo "")

          # Generate changelog
          if [ -z "$PREV_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges)
          else
            CHANGELOG=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi

          # Save to file to handle multiline
          echo "$CHANGELOG" > CHANGELOG.txt

      # Create or get release for the tag
      - name: Create release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ env.TAG_NAME }}
          release_name: Release ${{ env.TAG_NAME }}
          body_path: CHANGELOG.txt
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Remove any existing release assets with same names to avoid patch/update issues
      - name: Remove existing release assets
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const tag = process.env.TAG_NAME;

            // Get release by tag
            let release;
            try {
              release = await github.rest.repos.getReleaseByTag({
                owner,
                repo,
                tag
              });
            } catch (e) {
              core.info(`No release found for tag ${tag}. Will not try to delete assets.`);
              return;
            }

            const releaseId = release.data.id;
            const assets = await github.rest.repos.listReleaseAssets({
              owner,
              repo,
              release_id: releaseId
            });

            // Get list of files in dist directory
            const distPath = './dist';
            if (!fs.existsSync(distPath)) {
              core.info('dist directory does not exist');
              return;
            }

            function getAllFiles(dir, baseDir = '') {
              const files = [];
              const entries = fs.readdirSync(dir, { withFileTypes: true });
              
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                const relativePath = baseDir ? path.join(baseDir, entry.name) : entry.name;
                
                if (entry.isDirectory()) {
                  files.push(...getAllFiles(fullPath, relativePath));
                } else {
                  files.push(relativePath);
                }
              }
              
              return files;
            }

            const distFiles = getAllFiles(distPath);

            // Delete existing assets that match dist files
            for (const asset of assets.data) {
              if (distFiles.includes(asset.name) || distFiles.some(file => asset.name === path.basename(file))) {
                core.info(`Deleting existing asset ${asset.name} (id ${asset.id})`);
                await github.rest.repos.deleteReleaseAsset({
                  owner,
                  repo,
                  asset_id: asset.id
                });
              }
            }

      # Upload all files from dist directory
      - name: Upload dist files
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            const distPath = './dist';
            const uploadUrl = '${{ steps.create_release.outputs.upload_url }}';

            if (!fs.existsSync(distPath)) {
              core.setFailed('dist directory does not exist');
              return;
            }

            function getAllFiles(dir, baseDir = '') {
              const files = [];
              const entries = fs.readdirSync(dir, { withFileTypes: true });
              
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                const relativePath = baseDir ? path.join(baseDir, entry.name) : entry.name;
                
                if (entry.isDirectory()) {
                  files.push(...getAllFiles(fullPath, relativePath));
                } else {
                  files.push({ path: fullPath, name: relativePath });
                }
              }
              
              return files;
            }

            const files = getAllFiles(distPath);

            for (const file of files) {
              const fileName = path.basename(file.name);
              const ext = path.extname(file.path).toLowerCase();
              
              // Determine content type
              let contentType = 'application/octet-stream';
              if (ext === '.js') contentType = 'application/javascript';
              else if (ext === '.d.ts') contentType = 'text/plain';
              else if (ext === '.json') contentType = 'application/json';
              else if (ext === '.map') contentType = 'application/json';
              
              core.info(`Uploading ${file.name} as ${fileName}`);
              
              // Use curl to upload the file
              const curlCmd = `curl -X POST \
                -H "Authorization: token ${process.env.GITHUB_TOKEN}" \
                -H "Content-Type: ${contentType}" \
                --data-binary @"${file.path}" \
                "${uploadUrl}?name=${fileName}"`;
              
              try {
                execSync(curlCmd, { stdio: 'inherit' });
                core.info(`Successfully uploaded ${fileName}`);
              } catch (error) {
                core.error(`Failed to upload ${fileName}: ${error.message}`);
                throw error;
              }
            }

  publish:
    name: Publish to npm
    runs-on: ubuntu-latest
    needs: build-and-release
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"
          cache: "pnpm"
          registry-url: "https://registry.npmjs.org"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build
        run: pnpm run build

      - name: Publish to npm
        run: pnpm publish --access public --no-git-checks
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
